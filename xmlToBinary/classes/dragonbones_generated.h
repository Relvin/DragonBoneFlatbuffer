// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_DRAGONBONES_DRAGONBONES_H_
#define FLATBUFFERS_GENERATED_DRAGONBONES_DRAGONBONES_H_

#include "flatbuffers/flatbuffers.h"


namespace dragonBones {

struct Vec2Option;
struct TransformOption;
struct AreaDataOption;
struct RectangleDataOption;
struct TextDataOption;
struct DisplayOption;
struct SlotOption;
struct SkinOption;
struct BoneOption;
struct ColorTransformOption;
struct FrameOption;
struct TransformFrameOption;
struct TimelineOption;
struct NormalTimelineOption;
struct TransformTimelineOption;
struct AnimationOption;
struct ArmatureOption;
struct DragonBones;

MANUALLY_ALIGNED_STRUCT(4) Vec2Option {
 private:
  float x_;
  float y_;

 public:
  Vec2Option(float x, float y)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(Vec2Option, 8);

MANUALLY_ALIGNED_STRUCT(4) TransformOption {
 private:
  float x_;
  float y_;
  float skewX_;
  float skewY_;
  float scaleX_;
  float scaleY_;

 public:
  TransformOption(float x, float y, float skewX, float skewY, float scaleX, float scaleY)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), skewX_(flatbuffers::EndianScalar(skewX)), skewY_(flatbuffers::EndianScalar(skewY)), scaleX_(flatbuffers::EndianScalar(scaleX)), scaleY_(flatbuffers::EndianScalar(scaleY)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float skewX() const { return flatbuffers::EndianScalar(skewX_); }
  float skewY() const { return flatbuffers::EndianScalar(skewY_); }
  float scaleX() const { return flatbuffers::EndianScalar(scaleX_); }
  float scaleY() const { return flatbuffers::EndianScalar(scaleY_); }
};
STRUCT_END(TransformOption, 24);

struct AreaDataOption : private flatbuffers::Table {
  int8_t areaType() const { return GetField<int8_t>(4, 0); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4 /* areaType */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* name */) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct AreaDataOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_areaType(int8_t areaType) { fbb_.AddElement<int8_t>(4, areaType, 0); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(6, name); }
  AreaDataOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AreaDataOptionBuilder &operator=(const AreaDataOptionBuilder &);
  flatbuffers::Offset<AreaDataOption> Finish() {
    auto o = flatbuffers::Offset<AreaDataOption>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AreaDataOption> CreateAreaDataOption(flatbuffers::FlatBufferBuilder &_fbb,
   int8_t areaType = 0,
   flatbuffers::Offset<flatbuffers::String> name = 0) {
  AreaDataOptionBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_areaType(areaType);
  return builder_.Finish();
}

struct RectangleDataOption : private flatbuffers::Table {
  float width() const { return GetField<float>(4, 0); }
  float height() const { return GetField<float>(6, 0); }
  const TransformOption *transform() const { return GetStruct<const TransformOption *>(8); }
  const Vec2Option *pivot() const { return GetStruct<const Vec2Option *>(10); }
  const AreaDataOption *areaData() const { return GetPointer<const AreaDataOption *>(12); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4 /* width */) &&
           VerifyField<float>(verifier, 6 /* height */) &&
           VerifyField<TransformOption>(verifier, 8 /* transform */) &&
           VerifyField<Vec2Option>(verifier, 10 /* pivot */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* areaData */) &&
           verifier.VerifyTable(areaData()) &&
           verifier.EndTable();
  }
};

struct RectangleDataOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_width(float width) { fbb_.AddElement<float>(4, width, 0); }
  void add_height(float height) { fbb_.AddElement<float>(6, height, 0); }
  void add_transform(const TransformOption *transform) { fbb_.AddStruct(8, transform); }
  void add_pivot(const Vec2Option *pivot) { fbb_.AddStruct(10, pivot); }
  void add_areaData(flatbuffers::Offset<AreaDataOption> areaData) { fbb_.AddOffset(12, areaData); }
  RectangleDataOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RectangleDataOptionBuilder &operator=(const RectangleDataOptionBuilder &);
  flatbuffers::Offset<RectangleDataOption> Finish() {
    auto o = flatbuffers::Offset<RectangleDataOption>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<RectangleDataOption> CreateRectangleDataOption(flatbuffers::FlatBufferBuilder &_fbb,
   float width = 0,
   float height = 0,
   const TransformOption *transform = 0,
   const Vec2Option *pivot = 0,
   flatbuffers::Offset<AreaDataOption> areaData = 0) {
  RectangleDataOptionBuilder builder_(_fbb);
  builder_.add_areaData(areaData);
  builder_.add_pivot(pivot);
  builder_.add_transform(transform);
  builder_.add_height(height);
  builder_.add_width(width);
  return builder_.Finish();
}

struct TextDataOption : private flatbuffers::Table {
  uint8_t bold() const { return GetField<uint8_t>(4, 0); }
  uint8_t italic() const { return GetField<uint8_t>(6, 0); }
  uint8_t htmlText() const { return GetField<uint8_t>(8, 0); }
  uint8_t size() const { return GetField<uint8_t>(10, 0); }
  uint8_t alpha() const { return GetField<uint8_t>(12, 0); }
  uint8_t red() const { return GetField<uint8_t>(14, 0); }
  uint8_t green() const { return GetField<uint8_t>(16, 0); }
  uint8_t blue() const { return GetField<uint8_t>(18, 0); }
  uint16_t width() const { return GetField<uint16_t>(20, 0); }
  uint16_t height() const { return GetField<uint16_t>(22, 0); }
  int16_t letterSpacing() const { return GetField<int16_t>(24, 0); }
  int16_t lineSpacing() const { return GetField<int16_t>(26, 0); }
  int16_t maxCharacters() const { return GetField<int16_t>(28, 0); }
  const flatbuffers::String *face() const { return GetPointer<const flatbuffers::String *>(30); }
  const flatbuffers::String *text() const { return GetPointer<const flatbuffers::String *>(32); }
  uint8_t alignH() const { return GetField<uint8_t>(34, 0); }
  uint8_t alignV() const { return GetField<uint8_t>(36, 0); }
  uint8_t textType() const { return GetField<uint8_t>(38, 0); }
  uint8_t lineType() const { return GetField<uint8_t>(40, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* bold */) &&
           VerifyField<uint8_t>(verifier, 6 /* italic */) &&
           VerifyField<uint8_t>(verifier, 8 /* htmlText */) &&
           VerifyField<uint8_t>(verifier, 10 /* size */) &&
           VerifyField<uint8_t>(verifier, 12 /* alpha */) &&
           VerifyField<uint8_t>(verifier, 14 /* red */) &&
           VerifyField<uint8_t>(verifier, 16 /* green */) &&
           VerifyField<uint8_t>(verifier, 18 /* blue */) &&
           VerifyField<uint16_t>(verifier, 20 /* width */) &&
           VerifyField<uint16_t>(verifier, 22 /* height */) &&
           VerifyField<int16_t>(verifier, 24 /* letterSpacing */) &&
           VerifyField<int16_t>(verifier, 26 /* lineSpacing */) &&
           VerifyField<int16_t>(verifier, 28 /* maxCharacters */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 30 /* face */) &&
           verifier.Verify(face()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 32 /* text */) &&
           verifier.Verify(text()) &&
           VerifyField<uint8_t>(verifier, 34 /* alignH */) &&
           VerifyField<uint8_t>(verifier, 36 /* alignV */) &&
           VerifyField<uint8_t>(verifier, 38 /* textType */) &&
           VerifyField<uint8_t>(verifier, 40 /* lineType */) &&
           verifier.EndTable();
  }
};

struct TextDataOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bold(uint8_t bold) { fbb_.AddElement<uint8_t>(4, bold, 0); }
  void add_italic(uint8_t italic) { fbb_.AddElement<uint8_t>(6, italic, 0); }
  void add_htmlText(uint8_t htmlText) { fbb_.AddElement<uint8_t>(8, htmlText, 0); }
  void add_size(uint8_t size) { fbb_.AddElement<uint8_t>(10, size, 0); }
  void add_alpha(uint8_t alpha) { fbb_.AddElement<uint8_t>(12, alpha, 0); }
  void add_red(uint8_t red) { fbb_.AddElement<uint8_t>(14, red, 0); }
  void add_green(uint8_t green) { fbb_.AddElement<uint8_t>(16, green, 0); }
  void add_blue(uint8_t blue) { fbb_.AddElement<uint8_t>(18, blue, 0); }
  void add_width(uint16_t width) { fbb_.AddElement<uint16_t>(20, width, 0); }
  void add_height(uint16_t height) { fbb_.AddElement<uint16_t>(22, height, 0); }
  void add_letterSpacing(int16_t letterSpacing) { fbb_.AddElement<int16_t>(24, letterSpacing, 0); }
  void add_lineSpacing(int16_t lineSpacing) { fbb_.AddElement<int16_t>(26, lineSpacing, 0); }
  void add_maxCharacters(int16_t maxCharacters) { fbb_.AddElement<int16_t>(28, maxCharacters, 0); }
  void add_face(flatbuffers::Offset<flatbuffers::String> face) { fbb_.AddOffset(30, face); }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) { fbb_.AddOffset(32, text); }
  void add_alignH(uint8_t alignH) { fbb_.AddElement<uint8_t>(34, alignH, 0); }
  void add_alignV(uint8_t alignV) { fbb_.AddElement<uint8_t>(36, alignV, 0); }
  void add_textType(uint8_t textType) { fbb_.AddElement<uint8_t>(38, textType, 0); }
  void add_lineType(uint8_t lineType) { fbb_.AddElement<uint8_t>(40, lineType, 0); }
  TextDataOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TextDataOptionBuilder &operator=(const TextDataOptionBuilder &);
  flatbuffers::Offset<TextDataOption> Finish() {
    auto o = flatbuffers::Offset<TextDataOption>(fbb_.EndTable(start_, 19));
    return o;
  }
};

inline flatbuffers::Offset<TextDataOption> CreateTextDataOption(flatbuffers::FlatBufferBuilder &_fbb,
   uint8_t bold = 0,
   uint8_t italic = 0,
   uint8_t htmlText = 0,
   uint8_t size = 0,
   uint8_t alpha = 0,
   uint8_t red = 0,
   uint8_t green = 0,
   uint8_t blue = 0,
   uint16_t width = 0,
   uint16_t height = 0,
   int16_t letterSpacing = 0,
   int16_t lineSpacing = 0,
   int16_t maxCharacters = 0,
   flatbuffers::Offset<flatbuffers::String> face = 0,
   flatbuffers::Offset<flatbuffers::String> text = 0,
   uint8_t alignH = 0,
   uint8_t alignV = 0,
   uint8_t textType = 0,
   uint8_t lineType = 0) {
  TextDataOptionBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_face(face);
  builder_.add_maxCharacters(maxCharacters);
  builder_.add_lineSpacing(lineSpacing);
  builder_.add_letterSpacing(letterSpacing);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_lineType(lineType);
  builder_.add_textType(textType);
  builder_.add_alignV(alignV);
  builder_.add_alignH(alignH);
  builder_.add_blue(blue);
  builder_.add_green(green);
  builder_.add_red(red);
  builder_.add_alpha(alpha);
  builder_.add_size(size);
  builder_.add_htmlText(htmlText);
  builder_.add_italic(italic);
  builder_.add_bold(bold);
  return builder_.Finish();
}

struct DisplayOption : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  uint8_t type() const { return GetField<uint8_t>(6, 0); }
  uint8_t scalingGrid() const { return GetField<uint8_t>(8, 0); }
  int32_t scalingGridLeft() const { return GetField<int32_t>(10, 0); }
  int32_t scalingGridRight() const { return GetField<int32_t>(12, 0); }
  int32_t scalingGridTop() const { return GetField<int32_t>(14, 0); }
  int32_t scalingGridBottom() const { return GetField<int32_t>(16, 0); }
  const Vec2Option *point() const { return GetStruct<const Vec2Option *>(18); }
  const TransformOption *transform() const { return GetStruct<const TransformOption *>(20); }
  const TextDataOption *textData() const { return GetPointer<const TextDataOption *>(22); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, 6 /* type */) &&
           VerifyField<uint8_t>(verifier, 8 /* scalingGrid */) &&
           VerifyField<int32_t>(verifier, 10 /* scalingGridLeft */) &&
           VerifyField<int32_t>(verifier, 12 /* scalingGridRight */) &&
           VerifyField<int32_t>(verifier, 14 /* scalingGridTop */) &&
           VerifyField<int32_t>(verifier, 16 /* scalingGridBottom */) &&
           VerifyField<Vec2Option>(verifier, 18 /* point */) &&
           VerifyField<TransformOption>(verifier, 20 /* transform */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 22 /* textData */) &&
           verifier.VerifyTable(textData()) &&
           verifier.EndTable();
  }
};

struct DisplayOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_type(uint8_t type) { fbb_.AddElement<uint8_t>(6, type, 0); }
  void add_scalingGrid(uint8_t scalingGrid) { fbb_.AddElement<uint8_t>(8, scalingGrid, 0); }
  void add_scalingGridLeft(int32_t scalingGridLeft) { fbb_.AddElement<int32_t>(10, scalingGridLeft, 0); }
  void add_scalingGridRight(int32_t scalingGridRight) { fbb_.AddElement<int32_t>(12, scalingGridRight, 0); }
  void add_scalingGridTop(int32_t scalingGridTop) { fbb_.AddElement<int32_t>(14, scalingGridTop, 0); }
  void add_scalingGridBottom(int32_t scalingGridBottom) { fbb_.AddElement<int32_t>(16, scalingGridBottom, 0); }
  void add_point(const Vec2Option *point) { fbb_.AddStruct(18, point); }
  void add_transform(const TransformOption *transform) { fbb_.AddStruct(20, transform); }
  void add_textData(flatbuffers::Offset<TextDataOption> textData) { fbb_.AddOffset(22, textData); }
  DisplayOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DisplayOptionBuilder &operator=(const DisplayOptionBuilder &);
  flatbuffers::Offset<DisplayOption> Finish() {
    auto o = flatbuffers::Offset<DisplayOption>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<DisplayOption> CreateDisplayOption(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   uint8_t type = 0,
   uint8_t scalingGrid = 0,
   int32_t scalingGridLeft = 0,
   int32_t scalingGridRight = 0,
   int32_t scalingGridTop = 0,
   int32_t scalingGridBottom = 0,
   const Vec2Option *point = 0,
   const TransformOption *transform = 0,
   flatbuffers::Offset<TextDataOption> textData = 0) {
  DisplayOptionBuilder builder_(_fbb);
  builder_.add_textData(textData);
  builder_.add_transform(transform);
  builder_.add_point(point);
  builder_.add_scalingGridBottom(scalingGridBottom);
  builder_.add_scalingGridTop(scalingGridTop);
  builder_.add_scalingGridRight(scalingGridRight);
  builder_.add_scalingGridLeft(scalingGridLeft);
  builder_.add_name(name);
  builder_.add_scalingGrid(scalingGrid);
  builder_.add_type(type);
  return builder_.Finish();
}

struct SlotOption : private flatbuffers::Table {
  int32_t zOrder() const { return GetField<int32_t>(4, 0); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(6); }
  const flatbuffers::String *parent() const { return GetPointer<const flatbuffers::String *>(8); }
  uint8_t blendMode() const { return GetField<uint8_t>(10, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<DisplayOption>> *displays() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DisplayOption>> *>(12); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* zOrder */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* parent */) &&
           verifier.Verify(parent()) &&
           VerifyField<uint8_t>(verifier, 10 /* blendMode */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* displays */) &&
           verifier.Verify(displays()) &&
           verifier.VerifyVectorOfTables(displays()) &&
           verifier.EndTable();
  }
};

struct SlotOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_zOrder(int32_t zOrder) { fbb_.AddElement<int32_t>(4, zOrder, 0); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(6, name); }
  void add_parent(flatbuffers::Offset<flatbuffers::String> parent) { fbb_.AddOffset(8, parent); }
  void add_blendMode(uint8_t blendMode) { fbb_.AddElement<uint8_t>(10, blendMode, 0); }
  void add_displays(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DisplayOption>>> displays) { fbb_.AddOffset(12, displays); }
  SlotOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SlotOptionBuilder &operator=(const SlotOptionBuilder &);
  flatbuffers::Offset<SlotOption> Finish() {
    auto o = flatbuffers::Offset<SlotOption>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<SlotOption> CreateSlotOption(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t zOrder = 0,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<flatbuffers::String> parent = 0,
   uint8_t blendMode = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DisplayOption>>> displays = 0) {
  SlotOptionBuilder builder_(_fbb);
  builder_.add_displays(displays);
  builder_.add_parent(parent);
  builder_.add_name(name);
  builder_.add_zOrder(zOrder);
  builder_.add_blendMode(blendMode);
  return builder_.Finish();
}

struct SkinOption : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  const flatbuffers::Vector<flatbuffers::Offset<SlotOption>> *slots() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SlotOption>> *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* slots */) &&
           verifier.Verify(slots()) &&
           verifier.VerifyVectorOfTables(slots()) &&
           verifier.EndTable();
  }
};

struct SkinOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_slots(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SlotOption>>> slots) { fbb_.AddOffset(6, slots); }
  SkinOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SkinOptionBuilder &operator=(const SkinOptionBuilder &);
  flatbuffers::Offset<SkinOption> Finish() {
    auto o = flatbuffers::Offset<SkinOption>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<SkinOption> CreateSkinOption(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SlotOption>>> slots = 0) {
  SkinOptionBuilder builder_(_fbb);
  builder_.add_slots(slots);
  builder_.add_name(name);
  return builder_.Finish();
}

struct BoneOption : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  const flatbuffers::String *parent() const { return GetPointer<const flatbuffers::String *>(6); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  uint8_t inheritScale() const { return GetField<uint8_t>(10, 0); }
  uint8_t inheritRotation() const { return GetField<uint8_t>(12, 0); }
  const TransformOption *global() const { return GetStruct<const TransformOption *>(14); }
  const TransformOption *transform() const { return GetStruct<const TransformOption *>(16); }
  const flatbuffers::Vector<flatbuffers::Offset<RectangleDataOption>> *areaDatas() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RectangleDataOption>> *>(18); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* parent */) &&
           verifier.Verify(parent()) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           VerifyField<uint8_t>(verifier, 10 /* inheritScale */) &&
           VerifyField<uint8_t>(verifier, 12 /* inheritRotation */) &&
           VerifyField<TransformOption>(verifier, 14 /* global */) &&
           VerifyField<TransformOption>(verifier, 16 /* transform */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 18 /* areaDatas */) &&
           verifier.Verify(areaDatas()) &&
           verifier.VerifyVectorOfTables(areaDatas()) &&
           verifier.EndTable();
  }
};

struct BoneOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_parent(flatbuffers::Offset<flatbuffers::String> parent) { fbb_.AddOffset(6, parent); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  void add_inheritScale(uint8_t inheritScale) { fbb_.AddElement<uint8_t>(10, inheritScale, 0); }
  void add_inheritRotation(uint8_t inheritRotation) { fbb_.AddElement<uint8_t>(12, inheritRotation, 0); }
  void add_global(const TransformOption *global) { fbb_.AddStruct(14, global); }
  void add_transform(const TransformOption *transform) { fbb_.AddStruct(16, transform); }
  void add_areaDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RectangleDataOption>>> areaDatas) { fbb_.AddOffset(18, areaDatas); }
  BoneOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BoneOptionBuilder &operator=(const BoneOptionBuilder &);
  flatbuffers::Offset<BoneOption> Finish() {
    auto o = flatbuffers::Offset<BoneOption>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<BoneOption> CreateBoneOption(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<flatbuffers::String> parent = 0,
   int32_t length = 0,
   uint8_t inheritScale = 0,
   uint8_t inheritRotation = 0,
   const TransformOption *global = 0,
   const TransformOption *transform = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RectangleDataOption>>> areaDatas = 0) {
  BoneOptionBuilder builder_(_fbb);
  builder_.add_areaDatas(areaDatas);
  builder_.add_transform(transform);
  builder_.add_global(global);
  builder_.add_length(length);
  builder_.add_parent(parent);
  builder_.add_name(name);
  builder_.add_inheritRotation(inheritRotation);
  builder_.add_inheritScale(inheritScale);
  return builder_.Finish();
}

struct ColorTransformOption : private flatbuffers::Table {
  float alphaMultiplier() const { return GetField<float>(4, 0); }
  float redMultiplier() const { return GetField<float>(6, 0); }
  float greenMultiplier() const { return GetField<float>(8, 0); }
  float blueMultiplier() const { return GetField<float>(10, 0); }
  int32_t alphaOffset() const { return GetField<int32_t>(12, 0); }
  int32_t redOffset() const { return GetField<int32_t>(14, 0); }
  int32_t greenOffset() const { return GetField<int32_t>(16, 0); }
  int32_t blueOffset() const { return GetField<int32_t>(18, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4 /* alphaMultiplier */) &&
           VerifyField<float>(verifier, 6 /* redMultiplier */) &&
           VerifyField<float>(verifier, 8 /* greenMultiplier */) &&
           VerifyField<float>(verifier, 10 /* blueMultiplier */) &&
           VerifyField<int32_t>(verifier, 12 /* alphaOffset */) &&
           VerifyField<int32_t>(verifier, 14 /* redOffset */) &&
           VerifyField<int32_t>(verifier, 16 /* greenOffset */) &&
           VerifyField<int32_t>(verifier, 18 /* blueOffset */) &&
           verifier.EndTable();
  }
};

struct ColorTransformOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alphaMultiplier(float alphaMultiplier) { fbb_.AddElement<float>(4, alphaMultiplier, 0); }
  void add_redMultiplier(float redMultiplier) { fbb_.AddElement<float>(6, redMultiplier, 0); }
  void add_greenMultiplier(float greenMultiplier) { fbb_.AddElement<float>(8, greenMultiplier, 0); }
  void add_blueMultiplier(float blueMultiplier) { fbb_.AddElement<float>(10, blueMultiplier, 0); }
  void add_alphaOffset(int32_t alphaOffset) { fbb_.AddElement<int32_t>(12, alphaOffset, 0); }
  void add_redOffset(int32_t redOffset) { fbb_.AddElement<int32_t>(14, redOffset, 0); }
  void add_greenOffset(int32_t greenOffset) { fbb_.AddElement<int32_t>(16, greenOffset, 0); }
  void add_blueOffset(int32_t blueOffset) { fbb_.AddElement<int32_t>(18, blueOffset, 0); }
  ColorTransformOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ColorTransformOptionBuilder &operator=(const ColorTransformOptionBuilder &);
  flatbuffers::Offset<ColorTransformOption> Finish() {
    auto o = flatbuffers::Offset<ColorTransformOption>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<ColorTransformOption> CreateColorTransformOption(flatbuffers::FlatBufferBuilder &_fbb,
   float alphaMultiplier = 0,
   float redMultiplier = 0,
   float greenMultiplier = 0,
   float blueMultiplier = 0,
   int32_t alphaOffset = 0,
   int32_t redOffset = 0,
   int32_t greenOffset = 0,
   int32_t blueOffset = 0) {
  ColorTransformOptionBuilder builder_(_fbb);
  builder_.add_blueOffset(blueOffset);
  builder_.add_greenOffset(greenOffset);
  builder_.add_redOffset(redOffset);
  builder_.add_alphaOffset(alphaOffset);
  builder_.add_blueMultiplier(blueMultiplier);
  builder_.add_greenMultiplier(greenMultiplier);
  builder_.add_redMultiplier(redMultiplier);
  builder_.add_alphaMultiplier(alphaMultiplier);
  return builder_.Finish();
}

struct FrameOption : private flatbuffers::Table {
  int32_t position() const { return GetField<int32_t>(4, 0); }
  int32_t duration() const { return GetField<int32_t>(6, 0); }
  uint8_t frameType() const { return GetField<uint8_t>(8, 0); }
  const flatbuffers::String *action() const { return GetPointer<const flatbuffers::String *>(10); }
  const flatbuffers::String *event() const { return GetPointer<const flatbuffers::String *>(12); }
  const flatbuffers::String *sound() const { return GetPointer<const flatbuffers::String *>(14); }
  const flatbuffers::String *eventParameters() const { return GetPointer<const flatbuffers::String *>(16); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* position */) &&
           VerifyField<int32_t>(verifier, 6 /* duration */) &&
           VerifyField<uint8_t>(verifier, 8 /* frameType */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* action */) &&
           verifier.Verify(action()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* event */) &&
           verifier.Verify(event()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* sound */) &&
           verifier.Verify(sound()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 16 /* eventParameters */) &&
           verifier.Verify(eventParameters()) &&
           verifier.EndTable();
  }
};

struct FrameOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(int32_t position) { fbb_.AddElement<int32_t>(4, position, 0); }
  void add_duration(int32_t duration) { fbb_.AddElement<int32_t>(6, duration, 0); }
  void add_frameType(uint8_t frameType) { fbb_.AddElement<uint8_t>(8, frameType, 0); }
  void add_action(flatbuffers::Offset<flatbuffers::String> action) { fbb_.AddOffset(10, action); }
  void add_event(flatbuffers::Offset<flatbuffers::String> event) { fbb_.AddOffset(12, event); }
  void add_sound(flatbuffers::Offset<flatbuffers::String> sound) { fbb_.AddOffset(14, sound); }
  void add_eventParameters(flatbuffers::Offset<flatbuffers::String> eventParameters) { fbb_.AddOffset(16, eventParameters); }
  FrameOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FrameOptionBuilder &operator=(const FrameOptionBuilder &);
  flatbuffers::Offset<FrameOption> Finish() {
    auto o = flatbuffers::Offset<FrameOption>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<FrameOption> CreateFrameOption(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t position = 0,
   int32_t duration = 0,
   uint8_t frameType = 0,
   flatbuffers::Offset<flatbuffers::String> action = 0,
   flatbuffers::Offset<flatbuffers::String> event = 0,
   flatbuffers::Offset<flatbuffers::String> sound = 0,
   flatbuffers::Offset<flatbuffers::String> eventParameters = 0) {
  FrameOptionBuilder builder_(_fbb);
  builder_.add_eventParameters(eventParameters);
  builder_.add_sound(sound);
  builder_.add_event(event);
  builder_.add_action(action);
  builder_.add_duration(duration);
  builder_.add_position(position);
  builder_.add_frameType(frameType);
  return builder_.Finish();
}

struct TransformFrameOption : private flatbuffers::Table {
  uint8_t visible() const { return GetField<uint8_t>(4, 0); }
  uint8_t tweenScale() const { return GetField<uint8_t>(6, 0); }
  int32_t tweenRotate() const { return GetField<int32_t>(8, 0); }
  int32_t displayIndex() const { return GetField<int32_t>(10, 0); }
  float zOrder() const { return GetField<float>(12, 0); }
  float tweenEasing() const { return GetField<float>(14, 0); }
  const TransformOption *global() const { return GetStruct<const TransformOption *>(16); }
  const TransformOption *transform() const { return GetStruct<const TransformOption *>(18); }
  const Vec2Option *pivot() const { return GetStruct<const Vec2Option *>(20); }
  const Vec2Option *scaleOffset() const { return GetStruct<const Vec2Option *>(22); }
  const ColorTransformOption *color() const { return GetPointer<const ColorTransformOption *>(24); }
  const FrameOption *frame() const { return GetPointer<const FrameOption *>(26); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* visible */) &&
           VerifyField<uint8_t>(verifier, 6 /* tweenScale */) &&
           VerifyField<int32_t>(verifier, 8 /* tweenRotate */) &&
           VerifyField<int32_t>(verifier, 10 /* displayIndex */) &&
           VerifyField<float>(verifier, 12 /* zOrder */) &&
           VerifyField<float>(verifier, 14 /* tweenEasing */) &&
           VerifyField<TransformOption>(verifier, 16 /* global */) &&
           VerifyField<TransformOption>(verifier, 18 /* transform */) &&
           VerifyField<Vec2Option>(verifier, 20 /* pivot */) &&
           VerifyField<Vec2Option>(verifier, 22 /* scaleOffset */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 24 /* color */) &&
           verifier.VerifyTable(color()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 26 /* frame */) &&
           verifier.VerifyTable(frame()) &&
           verifier.EndTable();
  }
};

struct TransformFrameOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_visible(uint8_t visible) { fbb_.AddElement<uint8_t>(4, visible, 0); }
  void add_tweenScale(uint8_t tweenScale) { fbb_.AddElement<uint8_t>(6, tweenScale, 0); }
  void add_tweenRotate(int32_t tweenRotate) { fbb_.AddElement<int32_t>(8, tweenRotate, 0); }
  void add_displayIndex(int32_t displayIndex) { fbb_.AddElement<int32_t>(10, displayIndex, 0); }
  void add_zOrder(float zOrder) { fbb_.AddElement<float>(12, zOrder, 0); }
  void add_tweenEasing(float tweenEasing) { fbb_.AddElement<float>(14, tweenEasing, 0); }
  void add_global(const TransformOption *global) { fbb_.AddStruct(16, global); }
  void add_transform(const TransformOption *transform) { fbb_.AddStruct(18, transform); }
  void add_pivot(const Vec2Option *pivot) { fbb_.AddStruct(20, pivot); }
  void add_scaleOffset(const Vec2Option *scaleOffset) { fbb_.AddStruct(22, scaleOffset); }
  void add_color(flatbuffers::Offset<ColorTransformOption> color) { fbb_.AddOffset(24, color); }
  void add_frame(flatbuffers::Offset<FrameOption> frame) { fbb_.AddOffset(26, frame); }
  TransformFrameOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TransformFrameOptionBuilder &operator=(const TransformFrameOptionBuilder &);
  flatbuffers::Offset<TransformFrameOption> Finish() {
    auto o = flatbuffers::Offset<TransformFrameOption>(fbb_.EndTable(start_, 12));
    return o;
  }
};

inline flatbuffers::Offset<TransformFrameOption> CreateTransformFrameOption(flatbuffers::FlatBufferBuilder &_fbb,
   uint8_t visible = 0,
   uint8_t tweenScale = 0,
   int32_t tweenRotate = 0,
   int32_t displayIndex = 0,
   float zOrder = 0,
   float tweenEasing = 0,
   const TransformOption *global = 0,
   const TransformOption *transform = 0,
   const Vec2Option *pivot = 0,
   const Vec2Option *scaleOffset = 0,
   flatbuffers::Offset<ColorTransformOption> color = 0,
   flatbuffers::Offset<FrameOption> frame = 0) {
  TransformFrameOptionBuilder builder_(_fbb);
  builder_.add_frame(frame);
  builder_.add_color(color);
  builder_.add_scaleOffset(scaleOffset);
  builder_.add_pivot(pivot);
  builder_.add_transform(transform);
  builder_.add_global(global);
  builder_.add_tweenEasing(tweenEasing);
  builder_.add_zOrder(zOrder);
  builder_.add_displayIndex(displayIndex);
  builder_.add_tweenRotate(tweenRotate);
  builder_.add_tweenScale(tweenScale);
  builder_.add_visible(visible);
  return builder_.Finish();
}

struct TimelineOption : private flatbuffers::Table {
  int32_t duration() const { return GetField<int32_t>(4, 0); }
  float scale() const { return GetField<float>(6, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<TransformFrameOption>> *transformFrameList() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TransformFrameOption>> *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* duration */) &&
           VerifyField<float>(verifier, 6 /* scale */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* transformFrameList */) &&
           verifier.Verify(transformFrameList()) &&
           verifier.VerifyVectorOfTables(transformFrameList()) &&
           verifier.EndTable();
  }
};

struct TimelineOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_duration(int32_t duration) { fbb_.AddElement<int32_t>(4, duration, 0); }
  void add_scale(float scale) { fbb_.AddElement<float>(6, scale, 0); }
  void add_transformFrameList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TransformFrameOption>>> transformFrameList) { fbb_.AddOffset(8, transformFrameList); }
  TimelineOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TimelineOptionBuilder &operator=(const TimelineOptionBuilder &);
  flatbuffers::Offset<TimelineOption> Finish() {
    auto o = flatbuffers::Offset<TimelineOption>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<TimelineOption> CreateTimelineOption(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t duration = 0,
   float scale = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TransformFrameOption>>> transformFrameList = 0) {
  TimelineOptionBuilder builder_(_fbb);
  builder_.add_transformFrameList(transformFrameList);
  builder_.add_scale(scale);
  builder_.add_duration(duration);
  return builder_.Finish();
}

struct NormalTimelineOption : private flatbuffers::Table {
  int32_t duration() const { return GetField<int32_t>(4, 0); }
  float scale() const { return GetField<float>(6, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<FrameOption>> *frameList() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FrameOption>> *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* duration */) &&
           VerifyField<float>(verifier, 6 /* scale */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* frameList */) &&
           verifier.Verify(frameList()) &&
           verifier.VerifyVectorOfTables(frameList()) &&
           verifier.EndTable();
  }
};

struct NormalTimelineOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_duration(int32_t duration) { fbb_.AddElement<int32_t>(4, duration, 0); }
  void add_scale(float scale) { fbb_.AddElement<float>(6, scale, 0); }
  void add_frameList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FrameOption>>> frameList) { fbb_.AddOffset(8, frameList); }
  NormalTimelineOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NormalTimelineOptionBuilder &operator=(const NormalTimelineOptionBuilder &);
  flatbuffers::Offset<NormalTimelineOption> Finish() {
    auto o = flatbuffers::Offset<NormalTimelineOption>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<NormalTimelineOption> CreateNormalTimelineOption(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t duration = 0,
   float scale = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FrameOption>>> frameList = 0) {
  NormalTimelineOptionBuilder builder_(_fbb);
  builder_.add_frameList(frameList);
  builder_.add_scale(scale);
  builder_.add_duration(duration);
  return builder_.Finish();
}

struct TransformTimelineOption : private flatbuffers::Table {
  uint8_t transformed() const { return GetField<uint8_t>(4, 0); }
  float offset() const { return GetField<float>(6, 0); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(8); }
  const TransformOption *originTransform() const { return GetStruct<const TransformOption *>(10); }
  const Vec2Option *point() const { return GetStruct<const Vec2Option *>(12); }
  const TimelineOption *timeline() const { return GetPointer<const TimelineOption *>(14); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* transformed */) &&
           VerifyField<float>(verifier, 6 /* offset */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<TransformOption>(verifier, 10 /* originTransform */) &&
           VerifyField<Vec2Option>(verifier, 12 /* point */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* timeline */) &&
           verifier.VerifyTable(timeline()) &&
           verifier.EndTable();
  }
};

struct TransformTimelineOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transformed(uint8_t transformed) { fbb_.AddElement<uint8_t>(4, transformed, 0); }
  void add_offset(float offset) { fbb_.AddElement<float>(6, offset, 0); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(8, name); }
  void add_originTransform(const TransformOption *originTransform) { fbb_.AddStruct(10, originTransform); }
  void add_point(const Vec2Option *point) { fbb_.AddStruct(12, point); }
  void add_timeline(flatbuffers::Offset<TimelineOption> timeline) { fbb_.AddOffset(14, timeline); }
  TransformTimelineOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TransformTimelineOptionBuilder &operator=(const TransformTimelineOptionBuilder &);
  flatbuffers::Offset<TransformTimelineOption> Finish() {
    auto o = flatbuffers::Offset<TransformTimelineOption>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<TransformTimelineOption> CreateTransformTimelineOption(flatbuffers::FlatBufferBuilder &_fbb,
   uint8_t transformed = 0,
   float offset = 0,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   const TransformOption *originTransform = 0,
   const Vec2Option *point = 0,
   flatbuffers::Offset<TimelineOption> timeline = 0) {
  TransformTimelineOptionBuilder builder_(_fbb);
  builder_.add_timeline(timeline);
  builder_.add_point(point);
  builder_.add_originTransform(originTransform);
  builder_.add_name(name);
  builder_.add_offset(offset);
  builder_.add_transformed(transformed);
  return builder_.Finish();
}

struct AnimationOption : private flatbuffers::Table {
  uint8_t autoTween() const { return GetField<uint8_t>(4, 0); }
  int8_t frameRate() const { return GetField<int8_t>(6, 0); }
  int32_t playTimes() const { return GetField<int32_t>(8, 0); }
  float fadeTime() const { return GetField<float>(10, 0); }
  float tweenEasing() const { return GetField<float>(12, 0); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(14); }
  const NormalTimelineOption *timeline() const { return GetPointer<const NormalTimelineOption *>(16); }
  const flatbuffers::Vector<flatbuffers::Offset<TransformTimelineOption>> *timelineList() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TransformTimelineOption>> *>(18); }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *hideTimelineList() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(20); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* autoTween */) &&
           VerifyField<int8_t>(verifier, 6 /* frameRate */) &&
           VerifyField<int32_t>(verifier, 8 /* playTimes */) &&
           VerifyField<float>(verifier, 10 /* fadeTime */) &&
           VerifyField<float>(verifier, 12 /* tweenEasing */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 16 /* timeline */) &&
           verifier.VerifyTable(timeline()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 18 /* timelineList */) &&
           verifier.Verify(timelineList()) &&
           verifier.VerifyVectorOfTables(timelineList()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 20 /* hideTimelineList */) &&
           verifier.Verify(hideTimelineList()) &&
           verifier.VerifyVectorOfStrings(hideTimelineList()) &&
           verifier.EndTable();
  }
};

struct AnimationOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_autoTween(uint8_t autoTween) { fbb_.AddElement<uint8_t>(4, autoTween, 0); }
  void add_frameRate(int8_t frameRate) { fbb_.AddElement<int8_t>(6, frameRate, 0); }
  void add_playTimes(int32_t playTimes) { fbb_.AddElement<int32_t>(8, playTimes, 0); }
  void add_fadeTime(float fadeTime) { fbb_.AddElement<float>(10, fadeTime, 0); }
  void add_tweenEasing(float tweenEasing) { fbb_.AddElement<float>(12, tweenEasing, 0); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(14, name); }
  void add_timeline(flatbuffers::Offset<NormalTimelineOption> timeline) { fbb_.AddOffset(16, timeline); }
  void add_timelineList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TransformTimelineOption>>> timelineList) { fbb_.AddOffset(18, timelineList); }
  void add_hideTimelineList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> hideTimelineList) { fbb_.AddOffset(20, hideTimelineList); }
  AnimationOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimationOptionBuilder &operator=(const AnimationOptionBuilder &);
  flatbuffers::Offset<AnimationOption> Finish() {
    auto o = flatbuffers::Offset<AnimationOption>(fbb_.EndTable(start_, 9));
    return o;
  }
};

inline flatbuffers::Offset<AnimationOption> CreateAnimationOption(flatbuffers::FlatBufferBuilder &_fbb,
   uint8_t autoTween = 0,
   int8_t frameRate = 0,
   int32_t playTimes = 0,
   float fadeTime = 0,
   float tweenEasing = 0,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<NormalTimelineOption> timeline = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TransformTimelineOption>>> timelineList = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> hideTimelineList = 0) {
  AnimationOptionBuilder builder_(_fbb);
  builder_.add_hideTimelineList(hideTimelineList);
  builder_.add_timelineList(timelineList);
  builder_.add_timeline(timeline);
  builder_.add_name(name);
  builder_.add_tweenEasing(tweenEasing);
  builder_.add_fadeTime(fadeTime);
  builder_.add_playTimes(playTimes);
  builder_.add_frameRate(frameRate);
  builder_.add_autoTween(autoTween);
  return builder_.Finish();
}

struct ArmatureOption : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<SkinOption>> *skins() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SkinOption>> *>(4); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationOption>> *animations() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationOption>> *>(6); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(8); }
  const flatbuffers::Vector<flatbuffers::Offset<BoneOption>> *bones() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BoneOption>> *>(10); }
  const flatbuffers::Vector<flatbuffers::Offset<RectangleDataOption>> *areaDatas() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RectangleDataOption>> *>(12); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* skins */) &&
           verifier.Verify(skins()) &&
           verifier.VerifyVectorOfTables(skins()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* animations */) &&
           verifier.Verify(animations()) &&
           verifier.VerifyVectorOfTables(animations()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* bones */) &&
           verifier.Verify(bones()) &&
           verifier.VerifyVectorOfTables(bones()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* areaDatas */) &&
           verifier.Verify(areaDatas()) &&
           verifier.VerifyVectorOfTables(areaDatas()) &&
           verifier.EndTable();
  }
};

struct ArmatureOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkinOption>>> skins) { fbb_.AddOffset(4, skins); }
  void add_animations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationOption>>> animations) { fbb_.AddOffset(6, animations); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(8, name); }
  void add_bones(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BoneOption>>> bones) { fbb_.AddOffset(10, bones); }
  void add_areaDatas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RectangleDataOption>>> areaDatas) { fbb_.AddOffset(12, areaDatas); }
  ArmatureOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ArmatureOptionBuilder &operator=(const ArmatureOptionBuilder &);
  flatbuffers::Offset<ArmatureOption> Finish() {
    auto o = flatbuffers::Offset<ArmatureOption>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<ArmatureOption> CreateArmatureOption(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkinOption>>> skins = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationOption>>> animations = 0,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BoneOption>>> bones = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RectangleDataOption>>> areaDatas = 0) {
  ArmatureOptionBuilder builder_(_fbb);
  builder_.add_areaDatas(areaDatas);
  builder_.add_bones(bones);
  builder_.add_name(name);
  builder_.add_animations(animations);
  builder_.add_skins(skins);
  return builder_.Finish();
}

struct DragonBones : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  uint8_t autoSearch() const { return GetField<uint8_t>(6, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<ArmatureOption>> *armatures() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ArmatureOption>> *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, 6 /* autoSearch */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* armatures */) &&
           verifier.Verify(armatures()) &&
           verifier.VerifyVectorOfTables(armatures()) &&
           verifier.EndTable();
  }
};

struct DragonBonesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_autoSearch(uint8_t autoSearch) { fbb_.AddElement<uint8_t>(6, autoSearch, 0); }
  void add_armatures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArmatureOption>>> armatures) { fbb_.AddOffset(8, armatures); }
  DragonBonesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DragonBonesBuilder &operator=(const DragonBonesBuilder &);
  flatbuffers::Offset<DragonBones> Finish() {
    auto o = flatbuffers::Offset<DragonBones>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<DragonBones> CreateDragonBones(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   uint8_t autoSearch = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArmatureOption>>> armatures = 0) {
  DragonBonesBuilder builder_(_fbb);
  builder_.add_armatures(armatures);
  builder_.add_name(name);
  builder_.add_autoSearch(autoSearch);
  return builder_.Finish();
}

inline const DragonBones *GetDragonBones(const void *buf) { return flatbuffers::GetRoot<DragonBones>(buf); }

inline bool VerifyDragonBonesBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<DragonBones>(); }

inline void FinishDragonBonesBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<DragonBones> root) { fbb.Finish(root); }

}  // namespace dragonBones

#endif  // FLATBUFFERS_GENERATED_DRAGONBONES_DRAGONBONES_H_
